"""
На кольцевой автодороге с двусторонним движением находится
N заправочных станций. Длина кольцевой автодороги равна K км,
нулевой километр и K-й километр находятся в одной точке.
Код заправочной станции совпадает с расстоянием этой станции
до нулевой отметки дороги в километрах.
На заправочные станции нужно ежедневно доставлять бензин из бензохранилища,
которое требуется разместить рядом с одной из заправочных станций.
Бензин поставляется в цистернах объёмом V м3 каждая,
затраты на доставку вычисляются как
произведение расстояния на количество поездок бензовоза.
За один рейс бензовоз доставляет бензин только на одну заправочную станцию.
Бензохранилище расположено так,
чтобы суммарные затраты на доставку бензина были минимальными.

Определите минимально возможные суммарные затраты на доставку бензина.

Входные данные. Даны два входных файла,
каждый из которых в первой строке содержит три числа
N, K и V (1 < N ≤ 10 000 000, 1 < K ≤ 10 000 000, 1 < V ≤ 1000) –
количество заправочных станций,
длина кольцевой автодороги в километрах и объём цистерны.
В каждой из следующих N строк находятся два числа:
номер километра кольцевой автодороги,
на котором расположена заправочная станция, и количество бензина,
которое нужно туда доставить (все числа натуральные).
Заправочные станции перечисляются в порядке их расположения на автодороге.

Пример входного файла:
5 11 3
1 8
3 7
5 6
7 5
9 3

При таких исходных данных лучше всего расположить бензохранилище
около заправочной станции с кодом 3.
При этом затраты на доставку бензина составят
2·3 + 2·2 + 4·2 + 5·1 = 23. Ответ: 23.

В ответе укажите два числа:
сначала искомое значение для файла А,
затем для файла B.
"""
import math
a = open('B60.txt')
n,k,v = map(int,a.readline().split())
f = [list(map(int,a.readline().split())) for i in range(n)]
arr = [0 for i in range(5089573)]
for i in range(n):
    arr[f[i][0]]+=math.ceil(f[i][1]/v)
f = arr
cr = [0]
cl = [0]
for i in range(len(f)//2):
    cr[0]+=i*f[i]
for i in range(len(f)//2, len(f)):
    cl[0]+=(len(f)-i)*f[i]
cfr = sum(f[:len(f)//2])
cfl = sum(f[len(f)//2:])
c = [[cr[0]+cl[0], 0]]
for i in range(1,n):
    cr.append(cr[i-1]-cfr)
    cl.append(cl[i-1]+cfl)
    cfr-=f[i]
    cfl+=f[i]
    c.append([cr[i]+cl[i], i])

print(min(c, key = lambda a: a[0]), list(map(lambda a:a[0],c)).count(457363173365))